<p align="center">
  <img src="https://github.com/user-attachments/assets/382bd99f-9408-4baa-ba02-7646876a44be"  width="590" alt="CrowdSec AbuseIPDB Bouncer Logo" style="max-width: 100%; height: auto;">
</p>

# CrowdSec AbuseIPDB Bouncer
[![Build](https://github.com/developingchet/cs-abuseipdb-bouncer/actions/workflows/release.yml/badge.svg)](https://github.com/developingchet/cs-abuseipdb-bouncer/actions/workflows/release.yml)
[![Docker Pulls](https://img.shields.io/docker/pulls/developingchet/cs-abuseipdb-bouncer)](https://hub.docker.com/r/developingchet/cs-abuseipdb-bouncer)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

A production-ready, security-hardened CrowdSec bouncer that automatically reports malicious IP addresses to AbuseIPDB in real-time.

## Overview

This bouncer connects directly to the CrowdSec Local API and reports new ban decisions to AbuseIPDB's threat intelligence database. It is implemented as a single static Go binary running in a distroless container with no shell, no root privileges, and a read-only filesystem.

**Key capabilities:**

- Real-time reporting via the CrowdSec LAPI decision stream
- Concurrent worker pool — multiple HTTP round-trips to AbuseIPDB run in parallel, so high-frequency ban waves no longer stall the event loop
- Intelligent scenario-to-category mapping (covers 22 of 23 AbuseIPDB categories; category 2 DNS Poisoning is not generated by current scenario patterns)
- Per-IP cooldown enforcement (15-minute default, matching AbuseIPDB's deduplication window)
- Daily quota tracking with UTC midnight reset and disk persistence
- Optional pre-check to skip AbuseIPDB-whitelisted IPs before consuming report quota
- Exponential backoff retry with special handling for 422 (duplicate) and 429 (rate-limited) responses
- State persists across container restarts via named Docker volume
- Structured JSON logging compatible with Loki, Splunk, and other SIEM tools
- Zero PII in reports -- only scenario names are transmitted

**Security properties:**

- Runs as UID 65532 (nonroot) inside a distroless container
- No shell, no package manager, no OS utilities in the runtime image
- `cap_drop: ALL` and `read_only: true` by default in docker-compose.yml
- Seccomp syscall allowlist (`security/seccomp-bouncer.json`) blocks all syscalls not required by the binary
- TLS 1.2+ enforced on all outbound connections
- API keys loaded from environment variables only; 80-character hex keys and Bearer tokens are automatically redacted from log output
- Docker image is signed with [Cosign](https://docs.sigstore.dev/cosign/overview/) (keyless OIDC) and accompanied by a CycloneDX SBOM on every release

## How It Works

```
┌──────────────────────────────┐
│       CrowdSec LAPI          │
│       (port 8080 / 8443)     │
└──────────────┬───────────────┘
               │ polls every 30s
               │ GET /v1/decisions/stream
               │
               v
┌─────────────────────────────────────────────────────┐
│    cs-abuseipdb-bouncer (main event loop)           │
│                                                     │
│    Pre-queue filters (stateless, no I/O):           │
│    1. action = "add"                                │
│    2. exclude impossible-travel scenarios           │
│    3. origin = crowdsec / cscli                     │
│    4. scope = ip                                    │
│    5. value not empty                               │
│    6. reject private IPs                            │
│    7. min duration check                            │
│                                                     │
│              │  (non-blocking enqueue; drop →       │
│              │   buffer-full metric on overflow)    │
│              v                                      │
│    ┌─────────────────────────┐                      │
│    │  job queue (default 256)│                      │
│    └──────┬────────┬─────────┘                      │
│           │        │  (N workers, default 4)        │
│           v        v                                │
│    ┌──────────┐  ┌──────────┐                       │
│    │ Worker 1 │  │ Worker N │  8. CooldownConsume   │
│    │  atomic  │  │  atomic  │  9. QuotaConsume      │
│    │ bbolt tx │  │ bbolt tx │  (single transaction) │
│    └──────────┘  └──────────┘                       │
│                                                     │
│    Janitor goroutine (every 5m):                    │
│    - prune expired cooldown entries from state.db   │
│    - update cs_abuseipdb_bbolt_db_size_bytes gauge  │
└─────────────────────────────────────────────────────┘
         │                       ┌──────────────────────────┐
         │ HTTPS POST            │  Prometheus :9090        │
         │ /api/v2/report        │  GET /metrics            │
         │ retry: 3 attempts     │  GET /healthz            │
         │ 5s/10s backoff        │  GET /readyz             │
         │                       └──────────────────────────┘
         v
┌──────────────────────────────┐
│      AbuseIPDB v2 API        │
│      /report endpoint        │
└──────────────────────────────┘
```

New decisions stream continuously from the LAPI. Each decision passes through seven stateless pre-queue filters, then is handed off to a concurrent worker pool. Workers perform the quota and cooldown checks atomically (single bbolt transaction each) before dispatching to the AbuseIPDB sink. State is persisted to a named Docker volume so daily counts and per-IP cooldowns survive container restarts.

## Quick Start

**Prerequisites:**
- Docker with Compose v2
- Running CrowdSec instance with accessible LAPI
- AbuseIPDB account (free tier: 1000 reports/day)

**Steps:**

```bash
# Register the bouncer with CrowdSec and save the printed key
docker exec crowdsec cscli bouncers add abuseipdb-bouncer

# Clone the repository
git clone https://github.com/developingchet/cs-abuseipdb-bouncer.git
cd cs-abuseipdb-bouncer

# Configure environment
cp .env.example .env
chmod 600 .env
nano .env  # Set CROWDSEC_LAPI_KEY and ABUSEIPDB_API_KEY

# Build and start
docker compose build
docker compose up -d

# Verify startup
docker logs -f abuseipdb-bouncer
docker exec crowdsec cscli bouncers list
```

> If the container exits immediately with `permission denied` on `/data/state.db`, see [Volume Permissions](docs/TROUBLESHOOTING.md#volume-permission-denied-at-startup) in the troubleshooting guide.

Expected startup log (JSON format):

```json
{"level":"info","limit":1000,"used_today":0,"cooldown":"15m0s","precheck":false,"min_duration":"0s","log_level":"info","workers":4,"msg":"bouncer started"}
```

## Documentation

- **[Setup Guide](docs/SETUP.md)** - Complete installation procedures
- **[Configuration Reference](docs/CONFIGURATION.md)** - All environment variables explained
- **[Troubleshooting](docs/TROUBLESHOOTING.md)** - Common issues and solutions
- **[Design Rationale](docs/DESIGN.md)** - Architecture decisions and security analysis
- **[External References](docs/REFERENCES.md)** - Links to official documentation

## Repository Structure

```
.
├── cmd/
│   └── bouncer/
│       └── main.go                      # CLI entry point (Cobra)
├── internal/
│   ├── bouncer/
│   │   ├── bouncer.go                   # Main run loop + pre-queue filter pipeline
│   │   ├── bouncer_test.go
│   │   ├── janitor.go                   # Background cooldown pruner + DB size metric
│   │   ├── janitor_test.go
│   │   ├── pool.go                      # Concurrent worker pool
│   │   └── pool_test.go
│   ├── config/
│   │   ├── config.go                    # Env-based configuration
│   │   └── config_test.go
│   ├── decision/
│   │   ├── filter.go                    # Filter pipeline
│   │   ├── filter_test.go
│   │   ├── ip.go                        # Private IP detection
│   │   └── ip_test.go
│   ├── logger/
│   │   └── redact.go                    # RedactWriter: masks API keys and Bearer tokens in logs
│   ├── sink/
│   │   ├── sink.go                      # Sink interface
│   │   └── abuseipdb/
│   │       ├── categories.go            # Category ID constants
│   │       ├── categories_test.go
│   │       ├── client.go                # HTTP client (sync.Pool for response buffers)
│   │       ├── client_test.go
│   │       ├── mapper.go                # Scenario-to-category mapping
│   │       └── mapper_test.go
│   ├── metrics/
│   │   └── metrics.go                   # Prometheus metric definitions
│   └── storage/
│       ├── store.go                     # Storage interface
│       ├── bbolt.go                     # ACID bbolt persistence (quota + cooldown, atomic ops)
│       ├── bbolt_test.go
│       ├── bbolt_concurrent_test.go     # Concurrent correctness tests (-race)
│       └── mock.go                      # In-memory store for testing
├── security/
│   └── seccomp-bouncer.json             # OCI seccomp profile (minimal syscall allowlist)
├── docs/
│   ├── CONFIGURATION.md
│   ├── DESIGN.md
│   ├── REFERENCES.md
│   ├── SETUP.md
│   └── TROUBLESHOOTING.md
├── .env.example                         # Environment variable template
├── .gitignore
├── CONTRIBUTING.md
├── Dockerfile                           # Multi-stage: golang -> distroless
├── docker-compose.yml
├── go.mod
├── go.sum
├── LICENSE
├── SECURITY.md                          # Vulnerability disclosure policy
└── README.md
```

## Configuration Summary

All configuration is via environment variables. Required:

```bash
CROWDSEC_LAPI_URL=http://crowdsec:8080   # URL of the CrowdSec LAPI
CROWDSEC_LAPI_KEY=<from cscli bouncers add>
ABUSEIPDB_API_KEY=<from abuseipdb.com/account/api>
```

Optional (all have defaults):

```bash
ABUSEIPDB_DAILY_LIMIT=1000    # Free=1000, Webmaster=3000, Premium=50000
ABUSEIPDB_PRECHECK=false      # Pre-check /check endpoint before reporting
ABUSEIPDB_MIN_DURATION=0      # Skip decisions shorter than N seconds
COOLDOWN_DURATION=15m         # Per-IP cooldown window
POLL_INTERVAL=30s             # LAPI polling frequency
LOG_LEVEL=info                # trace, debug, info, warn, error
LOG_FORMAT=json               # json or text
TLS_SKIP_VERIFY=false         # Skip TLS verification (self-signed certs)
DATA_DIR=/data                # Directory for state.db (mount a named volume here)
METRICS_ADDR=:9090            # Address for /metrics, /healthz, /readyz (empty = disabled)
CONFIG_FILE=                  # Optional path to YAML config file

# Concurrent worker pool (v2.0)
WORKER_COUNT=4                # Goroutines sending reports concurrently (1–64)
WORKER_BUFFER=256             # In-memory job queue size (1–10000)
JANITOR_INTERVAL=5m           # How often to prune state.db and update DB size metric (min 30s)
```

See [CONFIGURATION.md](docs/CONFIGURATION.md) for complete details.

## Scenario Mapping

CrowdSec scenario names are mapped to AbuseIPDB categories via ordered substring matching. The author prefix is stripped and the name is lowercased before matching.

| Scenario Pattern | AbuseIPDB Categories | Description |
|------------------|---------------------|-------------|
| `*ssh*` | 22, 18 | SSH brute-force |
| `*sqli*`, `*sql-inj*` | 16, 21 | SQL injection |
| `*wordpress*`, `*drupal*` | 18, 21 | CMS attacks |
| `*http-dos*`, `*ddos*` | 4 | Denial of service |
| `*cve*`, `*log4*`, `*rce*` | 21, 20 | CVE exploitation |
| `*brute*`, `*-bf*`, `*rdp*` | 18 | Generic brute-force |
| (fallback) | 15 | Hacking |

Full 27-rule mapping table in [CONFIGURATION.md](docs/CONFIGURATION.md#scenario-category-mapping).

## Filtered Decisions

These decisions are intentionally never reported:

- **impossible-travel scenarios** - Account compromise heuristics, not IP-based abuse
- **CAPI and lists origins** - Community blocklist IPs that are already globally known
- **Private IP addresses** - RFC1918, loopback (127.0.0.0/8), link-local, CGNAT (100.64.0.0/10), and IPv6 private ranges
- **Non-IP scopes** - Ranges, ASNs, country-level decisions (AbuseIPDB only accepts single IPs)
- **IPs within the cooldown window** - Already reported within the past 15 minutes
- **Decisions exceeding the daily quota** - Once the limit is reached, no further reports are sent that UTC day

## State Persistence

State is stored in a single `state.db` file (bbolt embedded database) inside `DATA_DIR` (default `/data`, mounted as a named Docker volume):

```
/data/
└── state.db                  # bbolt database with two buckets:
    ├── quota                 # JSON record: {"count":42,"date":"2026-02-17"}
    └── cooldown              # Per-IP binary Unix timestamps (big-endian int64)
                              #   key: 203_0_113_42  (IPv4)
                              #   key: 2001_db8__1   (IPv6, colons → underscores)
```

Volume mount: `bouncer-state:/data`

The daily quota record resets automatically at UTC midnight. Cooldown entries are pruned by the background janitor (every 5 minutes by default, configurable via `JANITOR_INTERVAL`). Both survive container restarts via the named Docker volume.

## Observability

The HTTP server (enabled by default at `:9090`) exposes three endpoints:

| Endpoint | Description |
|----------|-------------|
| `GET /metrics` | Prometheus metrics in text exposition format |
| `GET /healthz` | Liveness probe — `ok` (HTTP 200) when the process is alive |
| `GET /readyz` | Readiness probe — HTTP 200 when LAPI is reachable, 503 otherwise |

Prometheus metrics:

| Metric | Type | Labels | Description |
|--------|------|--------|-------------|
| `cs_abuseipdb_decisions_processed_total` | Counter | — | All decisions received from the LAPI stream |
| `cs_abuseipdb_reports_sent_total` | Counter | — | Successful reports sent to AbuseIPDB |
| `cs_abuseipdb_decisions_skipped_total` | Counter | `filter` | Decisions dropped per filter stage |
| `cs_abuseipdb_api_errors_total` | Counter | `type` | API errors: `rate_limit`, `auth`, `network`, `timeout` |
| `cs_abuseipdb_quota_remaining` | Gauge | — | Remaining daily quota (resets at UTC midnight) |
| `cs_abuseipdb_bbolt_db_size_bytes` | Gauge | — | Size of `state.db` in bytes, updated by the janitor |

```bash
curl http://localhost:9090/metrics | grep cs_abuseipdb
```

## Logging

JSON format (default):

```json
{"time":1739836530,"level":"info","ip":"203.0.113.42","sink":"abuseipdb","daily":15,"limit":1000,"msg":"reported"}
{"time":1739836530,"level":"debug","ip":"192.168.1.1","filter":"private-ip","detail":"ip=192.168.1.1 is private/reserved","msg":"decision filtered (pre-queue)"}
```

Human-readable format (`LOG_FORMAT=text`):

```
12:15:30 INF reported ip=203.0.113.42 sink=abuseipdb daily=15 limit=1000
12:15:31 DBG decision filtered (pre-queue) ip=192.168.1.1 filter=private-ip
```

Enable debug logging:

```bash
# In .env:
LOG_LEVEL=debug
docker compose up -d --force-recreate abuseipdb-bouncer
```

## Supply-Chain Verification

Every release is signed with [Cosign](https://docs.sigstore.dev/cosign/overview/) using keyless OIDC (no stored private key). Verify the image signature:

```bash
cosign verify developingchet/cs-abuseipdb-bouncer:latest \
  --certificate-identity-regexp="https://github.com/developingchet/cs-abuseipdb-bouncer/.github/workflows/release.yml@refs/tags/.*" \
  --certificate-oidc-issuer="https://token.actions.githubusercontent.com"
```

A CycloneDX SBOM is attached to every GitHub Release and embedded as a Cosign attestation on the Docker image.

## Building

The binary compiles to approximately 8MB. Docker is required (Go does not need to be installed locally):

```bash
docker compose build
```

To run tests directly (requires Go 1.23+):

```bash
go test -race ./... -count=1 -timeout=120s
```

## Migration from v1.x

| Aspect | v1.x | v2.0 |
|--------|------|-------|
| State env var | `STATE_DIR` | `DATA_DIR` |
| Default path | `/tmp/cs-abuseipdb` | `/data` |
| Storage format | `daily` file + `cooldown/` directory | `state.db` (bbolt embedded database) |
| Volume mount | `bouncer-state:/tmp/cs-abuseipdb` | `bouncer-state:/data` |
| New in v2.0 | — | `METRICS_ADDR`, `CONFIG_FILE`, `WORKER_COUNT`, `WORKER_BUFFER`, `JANITOR_INTERVAL` |
| Supply-chain | — | Cosign keyless signing + CycloneDX SBOM |
| Runtime hardening | — | Seccomp syscall allowlist + log key redaction |

**No migration script is required.** On first start v2.0 creates a fresh `state.db`. The quota counter resets at UTC midnight anyway; cooldowns rebuild within one 15-minute window.

Update your compose file:
1. Change `STATE_DIR=/tmp/cs-abuseipdb` → `DATA_DIR=/data`
2. Change `- bouncer-state:/tmp/cs-abuseipdb` → `- bouncer-state:/data`
3. Optionally add `METRICS_ADDR=:9090` and expose port 9090

All new variables (`WORKER_COUNT`, `WORKER_BUFFER`, `JANITOR_INTERVAL`) have sensible defaults and require no changes to existing deployments.

## Contributing

Contributions are welcome. See [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

Areas where help is needed:
- Additional scenario pattern mappings
- Integration guides (Kubernetes, Proxmox, Synology)

## License

MIT License. See [LICENSE](LICENSE) for full text.

## Support

- **Issues:** https://github.com/developingchet/cs-abuseipdb-bouncer/issues
- **Discussions:** https://github.com/developingchet/cs-abuseipdb-bouncer/discussions
- **CrowdSec Discord:** https://discord.gg/crowdsec

## Acknowledgments

Thanks to the CrowdSec team for the `go-cs-bouncer` library and to AbuseIPDB for maintaining the IP reputation database.
